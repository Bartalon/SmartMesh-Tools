//////////////////////////////////////
////                              ////
////       SmartMesh  Tools       ////
////                              ////
//////////////////////////////////////
   //                          //
//////////////////////////////////////
////                              ////
////  Authored and Maintained by  ////
////                              ////
////  Dennis "Bartalon" Porter    ////
////                              ////
////  Dennis.Porter.3D@gmail.com  ////
////    www.DennisPorter3D.com    ////
////                              ////
//////////////////////////////////////
 /*

Installation Instructions:
1) Fully exit Maya.
2) Paste dpSmartMeshTools.mel into C:\Users\Owner\Documents\maya\2013-x64\scripts
    or equivalent scripts folder destination. Be sure to put it into the Scripts folder 
    located inside the 2013 folder (not the one inside the "maya" folder) or it won't install 
    properly.
3) Open Maya.
4) In Maya's MEL command line (or in the Script Editor), type in the following, then press enter:

source dpSmartMeshTools.mel; dpSmartMeshTools;


For updates check http://www.creativecrash.com/maya/script/smartmesh-tools
or www.DennisPorter3D.com/mel.htm

*/

global string $stRelease = "27 January 2019";
global string $stVersion = "1.2.0 BETA";


/////////////////////////////////
//  User-Adjustable Variables  //
/////////////////////////////////

//  If you do not want custom naming conventions, set these values to 0 for each operation you
//  do not want to automatically rename meshes.
//  (Save and re-source script or re-open SmartMesh Tools window. Restarting Maya not required)
//
//  ONLY USE VALUES  0  or  1
//  0 disables a feature
//  1 enables a feature
//  Be careful not to delete the semicolons (there should be one at
//  the end of each line in ths section

global int $smt_CustomNames_Combine = 1;
global int $smt_CustomNames_Separate = 1;
global int $smt_CustomNames_Extract = 1;
global int $smt_CustomNames_DupeFace = 1;

//////////////////////////////
//  SmartMesh Tools Window  //
//////////////////////////////

global proc dpSmartMeshTools() {
	global string $stVersion;

    // if (`window -ex stAboutWindow`) { deleteUI stAboutWindow; }
    if (`window -ex stBindHotkey`) { deleteUI stBindHotkey; }
	if (`window -ex smartMeshToolsWindow`) { deleteUI smartMeshToolsWindow; }

    window -mxb 0 -mnb 0 -tlb 1 -title ("SmartMesh Tools v" + $stVersion) -w 200 -s 0 smartMeshToolsWindow;
    	smt_buildUI();

    window -e -w 50 -h 50 smartMeshToolsWindow;
    showWindow smartMeshToolsWindow;
}

global proc smt_buildUI() {
	string $iconButtonName[] = {
		"smt_ico_combine",
		"smt_ico_separate",
		"smt_ico_extract",
		"smt_ico_duplicate" };
	string $buttonLabel[] = {
		"Smart Combine",
		"Smart Separate",
		"Smart Extract",
		"Smart Duplicate Face" };
	string $buttonImage[] = {
		"polyUnite.png",
		"polySeparate.png",
		"polyChipOff.png",
		"polyDuplicateFacet.png" };
	string $buttonCmd[] = {
		"dpSmartCombine()",
		"dpSmartSeparate()",
		"dpSmartExtractDuplicate(1)",
		"dpSmartExtractDuplicate(0)" };
	string $p = "smt_form_main";
	string $icoKey;
	int $top;
	int $h = 40;
	float $b = 0.23;

	formLayout -bgc .2 .2 .2 -p smartMeshToolsWindow $p;
		for ( $i=0; $i<`size $iconButtonName`; ++$i ) {
			string $ico = $iconButtonName[$i];
			$icoKey = $ico + "_hk";
			string $icoShelf = $ico + "_sb";
			string $lbl = $buttonLabel[$i];
			string $img = $buttonImage[$i];
			string $cmd = $buttonCmd[$i];

			iconTextButton -bgc $b $b $b -style "iconOnly" -h $h -image "text.png" -ann "Bind a hotkey" -c ( "stHotkey(" + $i + ")" ) $icoKey;
			iconTextButton -bgc $b $b $b -style "iconOnly" -h $h -w $h -image "factoryIcon.png" -ann "Create a shelf button" -c ( "dpSmartMeshToolButton(" + $i + ")" ) $icoShelf;
			iconTextButton -bgc $b $b $b -style "iconAndTextHorizontal" -w 150 -h $h -l $lbl -i $img -c $cmd $ico;

			formLayout -edit 
				-attachForm 	$ico 		"top" 	$top
				-attachForm 	$ico 		"left" 	75 
				-attachForm 	$ico 		"right" 0 
				-attachForm 	$icoKey 	"top" 	$top
				-attachForm 	$icoKey 	"left" 	0 
				-attachForm 	$icoShelf 	"top" 	$top
				-attachControl 	$icoShelf 	"left" 	-5 		$icoKey
			$p;

			$top = $top + $h;
			$b = .5 - $b;
		}

		iconTextButton -style "iconOnly" -h 30 -image "pickOtherComp.png" -ann "About SmartMesh Tools" -c "stAbout;" smt_ico_info;
		iconTextButton -style "iconOnly" -h 30 -image "factoryIcon.png" -c "dpSmartMeshToolButton(4);" -ann "Make a shelf button for this window" smt_ico_makeBtn;
		iconTextButton -bgc 0 0 0 -w 1 -h ($h * `size $iconButtonName`) -p $p divider;
		checkBox -l "Keep Empty Groups" -v 0 -ann "Keep empty groups after combining objects" -p $p smt_cb_groups;

		formLayout -edit 
			-attachForm 	smt_ico_info 	"bottom" 	0
			-attachForm 	smt_ico_info 	"right" 	0
			-attachForm 	smt_ico_makeBtn "bottom"	0
			-attachControl 	smt_ico_makeBtn "right" 	0 	smt_ico_info
			-attachForm 	divider 		"left" 		72
			-attachForm 	smt_cb_groups 	"bottom" 	7
			-attachForm 	smt_cb_groups 	"left" 		10
		$p;


}


/////////////////////
//  Smart Combine  //
/////////////////////

global proc dpSmartCombine() {
	string $sel[] = `ls -l -sl`;
	string $allGroups[] = `ls -l -type "transform"`;
	string $allJoints[] = `ls -l -type "joint"`;
	string $allCurves[] = `ls -l -type "nurbsCurve"`;
	string $allCameras[] = `listCameras`;
	$allGroups = stringArrayRemove($allJoints, $allGroups);
	$allGroups = stringArrayRemove($allCameras, $allGroups);
	$allGroups = stringArrayRemove($allCurves, $allGroups);

	// remove transform objects that have shape children (these are not groups)
	int $i = 0;
	while ( $i<`size $allGroups` ) {
		if ( (size(`listRelatives -f -s $allGroups[$i]`)) > 0 ) {
			stringArrayRemoveAtIndex($i, $allGroups);
		}
		else { ++$i; }
	}

	string $children[] = `listRelatives -ad -f`;
	string $allInHierarchy[] = stringArrayCatenate($sel, $children);
	int $s;

	//purge shape nodes
	while ($s < `size $allInHierarchy`) {
		string $item = $allInHierarchy[$s];
		string $shapes[] = `findType -t "shape" $item`;
		if ( $shapes[0] != "" ) { stringArrayRemoveAtIndex($s, $allInHierarchy); }
		else { ++$s; }
	}

	if ( `size $allInHierarchy` < 2 ) { warning "Select at least two objects to combine."; return; }

	string $groupsInHierarchy[];
	string $meshesInHierarchy[];
	// the constituentTopLevel (CTL) is the top-most object in a selection's hierarchy that is the source for all instanced objects below it.  
	// this is common when group objects containing multiple models have been instanced.  querying whether one of these models is an instance will
	// return true; however in cases like these, the true instance is the group rather than the model.
	string $constituentsTopLevels[];

	// check to see if anything is a constituent of a larger instance set
	int $index;
	int $constituentIndex[];
	for ( $obj in $allInHierarchy ) {
		if ( smt_isInstanceConstituent($obj) ) {
			$constituentsTopLevels[`size $constituentsTopLevels`] = smt_getInstanceConstituentTopLevel($obj);
			// the index keeps track of which object was a constituent so it can be removed later if user wants to omit CTLs
			$constituentIndex[`size $constituentIndex`] = $index;
		}
		++$index;
	}

	// prompt about omitting or including top levels of constituents
	string $msg = "One or more objects in your selection are constituents of a higher-level instance (typically a group that has been instanced).\n\nIn oder for combining to execute safely, you must either omit these constituents from the operation or include the entire instance hierarchy.\n\nBelow are the top-level instances of your selection:\n\n";

	$index = 0;
	for ( $obj in $constituentsTopLevels ) {
		string $sn[] = `ls -sn $allInHierarchy[$index]`;
		$msg = $msg + $sn[0] + "   is part of instance   " + $obj + "\n";
		++$index;
	}

	int $keepGroups = 1;
	if ( `size $constituentsTopLevels` > 0 ) {
		string $prompt = `confirmDialog -title "Instance Groups Detected"
							-message $msg
							-button "Omit Constituents"
							-button "Include Instance Groups"
							-button "Abort"
							-cancelButton "Abort"
							-defaultButton "Omit Constituents"`;

		if ( $prompt == "Abort" ) { return; }
		if ( $prompt == "Omit Constituents" ) { $keepGroups = 0; }
	}

	int $groups = `checkBox -q -v smt_cb_groups`; // Keep Empty Groups checkbox

	string $CTLobjects[];
	// process CTLs.  either convert and store the new UUID or omit them from $allInHierarchy to avoid convert/combine conflicts
	for ( $ctl in $constituentsTopLevels) {
		if ( $keepGroups ) {
			select $ctl;
			catchQuiet( ConvertInstanceToObject() );
			$CTLobjects = stringArrayCatenate($CTLobjects, `ls -uuid -sl`);
		}
		else {
			for ( $i in $constituentIndex ) {
				stringArrayRemoveAtIndex($i, $allInHierarchy);
			}

			// check to see if there are enough objects left in selection to combine
			if ( `size $allInHierarchy` < 2 ) { 
				select $sel;
				warning "Not enough objects remaining to combine.  Operation aborted."; 
				return; 
			}
		}
	}


	string $nonCTLobjects[];
	for ( $obj in $allInHierarchy ) {
		select $obj;

		if ( smt_isInstance($obj) ) {
			catchQuiet( ConvertInstanceToObject() );
		}

		$nonCTLobjects = stringArrayCatenate($nonCTLobjects, `ls -uuid -sl`);
	}

	select `ls -uuid $CTLobjects`;
	SelectHierarchy;
	select -add `ls -uuid $nonCTLobjects`;

	if ( $keepGroups ) {
		select -d $allGroups;
		Unparent;
	}

	CombinePolygons;
	DeleteHistory;

}


global proc string[] smt_getInstances(string $obj) {
	// get children of object (shapes).
	string $children[] = `listRelatives -fullPath -children $obj`;
	// find all the instances.  if there's more than one parent then it's an instance
	string $instances[];
	if ( `size $children` > 0 ) {
		$instances = `listRelatives -fullPath -allParents $children[0]`;
		// remove current object from results
		$instances = stringArrayRemove( { $obj }, $instances ); 
	}

	return $instances;
}

global proc string smt_getInstanceConstituentTopLevel(string $obj) {
	string $instances[] = smt_getInstances($obj);

	if (`size($instances)` > 0) { 
		string $instanceParents[] = `listRelatives -fullPath -allParents $obj`;

		int $kill;
		while ( `size $instanceParents` > 1 ) {
			string $p[] = `listRelatives -fullPath -allParents $instanceParents[0]`;
			if ( `size $p` > 1 ) { $instanceParents = $p; }
			else { break; }
			++$kill;
			if ( $kill > 500 ) { break; warning "Something went wrong and you managed to hit an infinite loop... Contact the author about this event."; }
		}

		for ( $p in $instanceParents ) {
			if ( `match $p $obj` == $p && smt_isInstance($p) ) {
				return $p;
			}
		}
		return $obj;
	}
	else { return $obj; }
}


global proc int smt_isInstance(string $obj) {
	if ( `size ( smt_getInstances($obj) )` > 0 ) {
		return 1;
	}
	return 0;
}


global proc int smt_isInstanceConstituent(string $obj) {
	string $instances[] = smt_getInstances($obj);

	if ( `size $instances` > 1 ) { return 0; }

	if ( smt_getInstanceConstituentTopLevel($obj) != $obj ) { return 1; }

	return 0;
}



//////////////////////
//  Smart Separate  //
//////////////////////

global proc dpSmartSeparate() {
	global int $smt_CustomNames_Separate;
	//  Currently does not correctly separate objects with children, but it doesn't seem to inadvertently delete anything either.
	string $oldName[];
	string $newName[];
	float $pivot[];
	//// Gather Info
	// A. Make sure ls belongs to exactly 1 mesh
	if (size(`listRelatives -p`) > 1 || size(`ls -sl`)>1) { error ("Separate only one mesh at a time."); }
	if (size(`ls -sl`) == 0) { error ("Nothing selected."); }
	if (size(`listRelatives -type "mesh" -p`) == 0 && size(`listRelatives -type "mesh" -c`) == 0) { error ("Invalid selection.  Select a mesh object to separate."); }

	// B. Get mesh name
	$oldName = `ls -l -sl`;

	// C. Figure out if object has _Sep_ already and remove it
	if (`gmatch $oldName[0] "*_Sep_*"`) {
		string $buffer[];
		tokenize $oldName[0] "_" $buffer;
		for ($slot in $buffer) {
			if ($slot != "Sep") { $newName[0] = ($newName[0] + $slot); }
			else { break; }
		}
	}
	else { $newName[0] = $oldName[0]; }
	$newName[0] = ($newName[0] + "_Sep_1");
	if (`gmatch $newName[0] "*Smart*"`) { $newName[0] = "SmartSeparate_1"; }

	// D. Store pivot location
	$pivot = `xform -q -ws -a -piv`;

	//// Do the things
	// 1.  Convert instance
	if (size(`listRelatives -ap (listRelatives("-f", "-s"))`) > 1) { ConvertInstanceToObject; }

	// 2.  Clear history, Separate delete group
	DeleteHistory;
	SeparatePolygon;
	if (size(`ls -sl`) == 1) { error "Mesh has no elements to separate."; }
	DeleteHistory;
	pickWalkUp;
	Ungroup;

	// 3.  Rename all bits
	if ($smt_CustomNames_Separate == 1) { // This is for if the user does not want the custom naming conventions
		for ($chip in `ls -sl`) { rename $chip $newName[0];	}
	}

	// 4.  Reposition pivot
	xform -ws -a -rp $pivot[0] $pivot[1] $pivot[2];
	xform -ws -a -sp $pivot[0] $pivot[1] $pivot[2];
}


//////////////////////
//  Smart Extract   //
//  Smart Duplcate  //
//////////////////////

// Extract and duplicate function similarly, with the only real difference being Extract
// does not leave the selected faces behind on the old object
global proc dpSmartExtractDuplicate(int $option) {
	global int $smt_CustomNames_DupeFace;
	global int $smt_CustomNames_Extract;
	string $mode[] = { "Duplicate", "Extract" };
	string $match[] = { "*_Dup_*", "*_Ext_*" };
	string $suffix[] = { "_Dup_1", "_Ext_1" };
	string $newName[];
	string $buffer[];
	string $newFaces[];
	// Gather Info
	// A. Make sure ls belongs to exactly 1 mesh
	if (size(`listRelatives -p`) > 1) { error ($mode[$option] + " faces from one mesh at a time."); }
	if (size(`listRelatives -p`) == 0) { error ("Select a component to " + $mode[$option]); }
	if (size(`listRelatives -type "mesh" -p`) == 0) { error ("Invalid selection. Select a mesh component to " + $mode[$option] + "."); }

	// B. Convert to Faces and store selection
	ConvertSelectionToFaces;
	string $oldFaces[] = `ls -l -fl -sl`;

	// C. Store mesh belonging to components
	string $oldName[] = `listRelatives -f -p (listRelatives("-p","-f", $oldFaces[0]))`;

	// D. Check if mesh already contains _Dup_ or _Ext_
	if (`gmatch $oldName[0] $match[$option]`) {
		// E. Tokenize & adjust for final chronological name
		tokenize $oldName[0] "_" $buffer;
		for ($slot in $buffer) {
			if ($slot != "Dup" && $slot != "Ext") { $newName[0] = ($newName[0] + $slot); }
			else { break; }
		}
	}
	else { $newName[0] = $oldName[0]; }
	$newName[0] = ($newName[0] + $suffix[$option]);
	if (`gmatch $newName[0] "*Smart*"` && $option == 0) { $newName[0] = "SmartDuplicate_1"; }
	if (`gmatch $newName[0] "*Smart*"` && $option == 1) { $newName[0] = "SmartExtract_1"; }

	////  Do The Things
	// 1.  Duplicate
	if ($smt_CustomNames_DupeFace == 1 && $option == 0) { // Duplicate Face
		$newName = `duplicate -n $newName[0] $oldName[0]`;
	}
	else if ($smt_CustomNames_Extract == 1 && $option == 1) { // Extract
		$newName = `duplicate -n $newName[0] $oldName[0]`;
	}
	else if ($option == 1 || $option == 0) {
		$newName = `duplicate $oldName[0]`;
	}

	// 2. Switch over components from old name to new name
	for ($i=0; $i<`size $oldFaces`; ++$i) {
		tokenize $oldFaces[$i] "." $buffer;
		$newFaces[$i] = ($newName[0] + "." + $buffer[1]);
	}

	// 3.  Delete Children
	select `listRelatives -f -c $newName[0]`;
	select -d `ls -type "mesh" -sl`;
	if (size(`ls -sl`) > 0) { delete; }

	// 4.  Delete appropriate faces on new
	select $newName[0];
	ConvertSelectionToFaces;
	select -d $newFaces;
	delete;

	// 5.  If Extract, delete faces on old (wont delete anything if duplicating face)
	if ($option == 1) { delete $oldFaces; }
	select $newName[0];
	selectMode -o;
}


/////////////////////
//  Shelf Buttons  //
/////////////////////

global proc dpSmartMeshToolButton(int $option) {
	global string $gShelfTopLevel;
	global string $stVersion;
	string $currentShelf = `tabLayout -q -st $gShelfTopLevel`;
	
	setParent ($gShelfTopLevel + "|" + $currentShelf);
	
	switch ($option) {

		case 0:	    
	        shelfButton
	            -label "Smart Combine"
	            -annotation "Smart Combine"
	            -image1 "polyUnite.png"
	            -command "source dpSmartMeshTools.mel; dpSmartCombine;";

		break;
		case 1:
	        shelfButton
	            -label "Smart Separate"
	            -annotation "Smart Separate"
	            -image1 "polySeparate.png"
	            -command "source dpSmartMeshTools.mel; dpSmartSeparate;";

		break;
		case 2:
	        shelfButton
	            -label "Smart Extract"
	            -annotation "Smart Extract"
	            -image1 "polyChipOff.png"
	            -command "source dpSmartMeshTools.mel; dpSmartExtractDuplicate(1);";

		break;
		case 3:
	        shelfButton
	            -label "Smart Duplicate Face"
	            -annotation "Smart Duplicate Face"
	            -image1 "polyDuplicateFacet.png"
	            -command "source dpSmartMeshTools.mel; dpSmartExtractDuplicate(0);";

		break;
    	case 4:    
	        shelfButton
	            -label ( "SmartMesh Tools v" + $stVersion )
	            -annotation "Launch SmartMesh Tools Window"
	            -image1 "polyAssignSubdivHole.png"
	            -command "source dpSmartMeshTools.mel; dpSmartMeshTools;";

		break;

		warning "Shelf button created.";
    }

}


///////////////////////
//  Binding Hotkeys  //
///////////////////////

global proc stHotkey(int $option) {
    global string $stVersion;
    string $title[] = { 
    	"Bind Hotkey for Smart Combine", 
    	"Bind Hotkey for Smart Separate", 
    	"Bind Hotkey for Smart Extract",
    	"Bind Hotkey for Smart Duplicate Face" };
    string $descrip[] = {
    	"This hotkey will perform a smarter version of Maya's default operation of \"Mesh > Combine\".",
	    "This hotkey will perform a smarter version of Maya's default operation of \"Mesh > Separate\".",
	    "This hotkey will perform a smarter version of Maya's default operation of \"Mesh > Extract\".",
		"This hotkey will perform a smarter version of Maya's default operation of \"Edit Mesh > Duplicate Face\"." };
	string $recommend[] = {
		"(Recommended Ctrl + Alt + Shift + C)",
		"(Recommended Ctrl + Alt + Shift + S)",
		"(Recommended Ctrl + Alt + Shift + E)",
		"(Recommended Ctrl + Alt + Shift + D)" };
    string $key[] = { 
    	"C",
        "S", 
        "E", 
        "D" };

    if (`window -exists stBindHotkey`) {
        deleteUI stBindHotkey;
        windowPref -remove stBindHotkey;
    }

    window -mxb 0 -mnb 0 -tlb 1 -title $title[$option] -w 200 stBindHotkey;
        gridLayout -numberOfColumns 1 -cellWidthHeight 300 185;
            gridLayout -numberOfColumns 1 -cellWidthHeight 300 135;
                scrollField -wordWrap true -editable false
                -text ("Choose a desired hotkey.  The hotkey is case sensitive!\n\n" + $descrip[$option] + "\n\n" + $recommend[$option]);
                gridLayout -numberOfColumns 3 -cellWidthHeight 100 50;
                    gridLayout -numberOfColumns 1 -cellWidthHeight 75 50;
                        textFieldGrp -text $key[$option] hotkeyField;
                    setParent..;
                    gridLayout -numberOfColumns 2 -cellWidthHeight 50 50;
                        checkBox -label "Alt" -v 1 altCheck;
                        checkBox -label "Ctrl" -v 1 ctrlCheck;
                    setParent..;
                    gridLayout -numberOfColumns 1 -cellWidthHeight 100 50;
                        if ( $option == 0 ) { button -label "ASSIGN" -command "stMenuHotkey(0)"; }
                        else if ( $option == 1) { button -label "ASSIGN" -command "stMenuHotkey(1)"; }
                        else if ( $option == 2) { button -label "ASSIGN" -command "stMenuHotkey(2)"; }
                        else if ( $option == 3) { button -label "ASSIGN" -command "stMenuHotkey(3)"; }
                    setParent..;
                setParent..;
            setParent..;
        setParent..;
        
	showWindow stBindHotkey;
    setFocus hotkeyField;
}

global proc stMenuHotkey(int $option) {
    int $keyLength;
    string $namedCmd;
    string $hotkeyAnn[] = { "Smart Combine", "Smart Separate", "Smart Extract", "Smart Duplicate Face" };

    $key = `textFieldGrp -q -text hotkeyField`;
    $keyLength = `size $key`;
    $alt = `checkBox -q -v "altCheck"`;
    $ctrl = `checkBox -q -v "ctrlCheck"`;

    if ( $keyLength > 1 ) { error "Hotkey must be a single character."; }
    if ( $key == " " ) { error "Hotkey may not be bound to the space bar."; }
    if ( $key == "" ) { error "Hotkey must be a single character."; }
    
    string $rebindConfirm = `confirmDialog
        -title "Confirm hotkey bind"
        -message "Are you sure you want to bind this hotkey?  This is NOT undoable and will remain bound until you change the binding in the Hotkey Editor."
        -button "Bind It"
        -button "Cancel"
        -defaultButton "Cancel"
        -cancelButton "Cancel"
        -dismissString "Cancel"`;
        
    if ( $rebindConfirm == "Bind It" ) {
        if ( $option == 0 ) {
            nameCommand -annotation $hotkeyAnn[$option] -command "source dpSmartMeshTools; dpSmartCombine;" dpSmartCombineNamedCommand;
            $namedCmd = "dpSmartCombineNamedCommand";
        }
        else if ( $option == 1 ) {
            nameCommand -annotation $hotkeyAnn[$option] -command "source dpSmartMeshTools; dpSmartSeparate;" dpSmartSeparateNamedCommand;
            $namedCmd = "dpSmartSeparateNamedCommand";
        }
        else if ( $option == 2 ) {
            nameCommand -annotation $hotkeyAnn[$option] -command "source dpSmartMeshTools; dpSmartExtractDuplicate(1);" dpSmartExtractNamedCommand;
            $namedCmd = "dpSmartExtractNamedCommand";
        }
        else if ( $option == 3 ) {
            nameCommand -annotation $hotkeyAnn[$option] -command "source dpSmartMeshTools; dpSmartExtractDuplicate(0);" dpSmartDupeFaceNamedCommand;
            $namedCmd = "dpSmartDupeFaceNamedCommand";
        }


        if ( $alt == "0" && $ctrl == "0" ) {
            hotkey -k $key -name $namedCmd;
            warning ( "Hotkey assigned to the " + $key + " key." );
        }
        else if ( $alt == "1" && $ctrl == "0" ) {
            hotkey -k $key -alt -name $namedCmd;
            warning ( "Hotkey assigned to Alt + " + $key + "\"." );
        }
        else if ( $alt == "0" && $ctrl == "1" ) {
            hotkey -k $key -ctl -name $namedCmd;
            warning ( "Hotkey assigned to Ctrl + " + $key + "\"." );
        }
        else if ( $alt == "1" && $ctrl == "1" ) {
            hotkey -k $key -alt -ctl -name $namedCmd;
            warning ( "Hotkey assigned to Alt + Ctrl + " + $key + "\"." );
        }    
    }
    deleteUI stBindHotkey;
    windowPref -remove stBindHotkey;
}

////////////////////
//  About Button  //
////////////////////

global proc stAbout() {
	global string $stVersion;
	global string $stRelease;
	string $p = "smt_form_main";
	string $wnd = "smartMeshToolsWindow";
	int $w = `window -q -w $wnd`;
	int $h = `window -q -h $wnd`;
	float $col[] = { 0.115, 0.357, 0.500 };
	float $f = .2;

	deleteUI $p;

	// Fancy window extension
	smt_resizeWindow(1);

	formLayout -bgc $f $f $f -p $wnd $p;
		scrollField -bgc $f $f $f -wordWrap true -editable false
			-text ( "SmartMesh Tools v" + $stVersion + " released " + $stRelease + " for Maya 2012 thru 2018.\n\nContact Dennis.Porter.3D@gmail.com with any bugs, comments, or questions.\n\nRefer to commented lines at the top of the .mel file for script information and modification instructions." )
			smt_scroll_info;

		// iconTextButton -style "textOnly" -l "SmartMesh Tools on CreativeCrash" -c "system(\"shell start http://www.creativecrash.com/maya/script/smartmesh-tools\");";
		// iconTextButton -style "textOnly" -l "Author Website" -bgc .2 .2 .2 ;

		iconTextButton -h 20 -bgc .35 .35 .35 -style "iconAndTextHorizontal" -w 185 -l "SmartMesh Tools on HighEnd3D" -c "system(\"shell start http://www.creativecrash.com/maya/script/smartmesh-tools\")" smt_btn_he;
		iconTextButton -h 20 -bgc .35 .35 .35 -style "iconAndTextHorizontal" -w 185 -l "SmartMesh Tools on Gumroad" -c "system(\"shell start https://www.gumroad.com/dennisporter3d\");" smt_btn_gr;
		iconTextButton -h 20 -bgc .35 .85 .35 -style "iconAndTextHorizontal" -w 125 -l "Author ArtStation" -c "system(\"shell start https://www.artstation.com/dennisporter3d\");" smt_btn_as;
		iconTextButton -h 20 -bgc .2117 .2235 .2431 -style "iconAndTextHorizontal" -w 125 -l "Discord Server" -c "system(\"shell start https://discord.gg/VVB9RT8\");" smt_btn_gg;
		iconTextButton -h 20 -bgc $col[0] $col[1] $col[2] -style "textOnly" -w 25 -l "OK" -c ( "deleteUI " + $p + "; smt_resizeWindow(-1); smt_buildUI();" ) smt_btn_ok;



	int $pad = 10;
	formLayout -edit 
		-attachForm 	smt_scroll_info 		"top" 		0
		-attachForm 	smt_scroll_info 		"bottom"	0
		-attachForm 	smt_scroll_info 		"left" 		5
		-attachForm 	smt_scroll_info 		"right" 	0

		-attachForm 	smt_btn_ok 				"bottom" 	$pad
		-attachForm		smt_btn_ok 				"right" 	$pad

		-attachForm 	smt_btn_he				"bottom" 	$pad
		-attachForm		smt_btn_he				"left" 		$pad
		-attachForm 	smt_btn_gr				"bottom" 	35
		-attachForm		smt_btn_gr				"left"	 	$pad
		-attachForm 	smt_btn_gg				"bottom" 	35
		-attachForm		smt_btn_gg				"right"	 	50
		-attachForm 	smt_btn_as				"bottom" 	$pad
		-attachForm		smt_btn_as				"right" 	50

	$p;
}


global proc smt_resizeWindow(int $direction) {
	$direction = min(1, $direction);
	$direction = max(-1, $direction);

	$direction = $direction * 2;
	int $limit = 60;

	string $wnd = "smartMeshToolsWindow";
	int $w = `window -q -w $wnd`;
	int $h = `window -q -h $wnd`;

	// Fancy window extension
	for ( $i=0; $i<$limit; ++$i ) {
		window -e -w ($w + $direction) $wnd;
		if ( $i % 5 == 0 ) { 
			window -e -h ( $h + $direction ) $wnd;
			$h = $h + $direction;
		}
		$w = $w + $direction;
		refresh;
	}


}